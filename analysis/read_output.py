"""Utility functions for reading simulation output files.

This module provides small, focused helpers to load node positions, bond
information, and boundary indices from input/output files generated by the
simulator. All functions are pure readers: they do not modify files.
"""

from __future__ import annotations

from pathlib import Path
from typing import List, Tuple

import numpy as np
import matplotlib.pyplot as plt


def _resolve_run_dir(base_dir: str | Path, run_no: int | None) -> Path:
    """Return the directory that contains run output files.

    If `run_no` is provided, the directory is `base_dir/RunXX`; otherwise it is
    `base_dir` itself.
    """
    base = Path(base_dir)
    return base / f"Run{run_no:02}" if run_no is not None else base


def read_init_pos(dir: str | Path) -> np.ndarray:
    """
    Load initial node positions from nodes.inp.

    Returns
    -------
    np.ndarray
        Array of shape (N, 2) with node coordinates.
    """
    nodes_path = Path(dir) / "nodes.inp"
    with nodes_path.open() as f:
        raw = f.readlines()[1:]  # skip header line

    # Each row is: x y ... trailing label
    posxy: List[List[str]] = []
    for line in raw:
        posxy.append(line.rstrip().split(" ")[:-1])

    return np.array(posxy, dtype=float)


def read_pos(dir: str | Path, run_no: int | None = None) -> Tuple[List[np.ndarray], int]:
    """
    Load pos.txt and return all frames with initial node count.

    Parameters
    ----------
    dir
        Base directory for output files.
    run_no
        Optional run number; if set, files are read from RunXX subfolder.

    Returns
    -------
    (frames, Ninit)
        frames: list of arrays (N_i, 2) for each timestep
        Ninit: initial number of nodes
    """
    dirin = _resolve_run_dir(dir, run_no)
    pos_path = dirin / "pos.txt"

    frames: List[np.ndarray] = []
    with pos_path.open() as f:
        # First line contains the initial number of nodes
        Ninit = int(f.readline().split(" ")[0])

        # Each frame starts with a line containing N, followed by N rows of xy
        while line := f.readline().split(" ")[0]:
            N = int(line)
            posxy: List[List[str]] = []
            for _ in range(N):
                l = f.readline()
                posxy.append(l.rstrip().split(" "))
            frames.append(np.array(posxy, dtype=float))

    return frames, Ninit


def read_init_bonds(dir: str | Path) -> np.ndarray:
    """
    Load initial bond indices from bonds.inp.

    Returns
    -------
    np.ndarray
        Array of shape (Nbonds, 2) with node index pairs.
    """
    bonds_path = Path(dir) / "bonds.inp"
    with bonds_path.open() as f:
        raw = f.readlines()[1:]  # skip header

    ind_bonds: List[List[str]] = []
    for line in raw:
        ind_bonds.append(line.rstrip().split(" ")[:2])

    return np.array(ind_bonds, dtype=int)


def read_bonds(dir: str | Path, run_no: int | None = None) -> List[np.ndarray]:
    """
    Load bond data and split into frames.

    Returns
    -------
    list[np.ndarray]
        List of per-timestep bond arrays.
    """
    dirin = _resolve_run_dir(dir, run_no)

    # The first line of bonds.inp contains the total number of bonds
    with (Path(dir) / "bonds.inp").open() as f:
        N_bonds = int(f.readline().split(" ")[0])

    bond_data = np.loadtxt(dirin / "bondnew.txt", dtype=float)
    bondframes = np.array_split(bond_data, bond_data.shape[0] / N_bonds)
    return bondframes


def read_boundary_indeces(dir: str | Path) -> Tuple[np.ndarray, np.ndarray]:
    """
    Return indices of boundary nodes (bottom and top) from nodes.inp.

    This assumes the boundary flag is the third column in nodes.inp and that
    bottom nodes appear first, followed by top nodes.
    """
    nodes_path = Path(dir) / "nodes.inp"
    with nodes_path.open() as f:
        raw = f.readlines()[1:]

    boundary_flag = np.array([int(line.strip().split(" ")[2]) for line in raw])
    boundary_inds = np.where(boundary_flag == 1)[0]

    half = boundary_inds.shape[0] // 2
    boundary_inds_bot = boundary_inds[:half]
    boundary_inds_top = boundary_inds[half:]

    return boundary_inds_bot, boundary_inds_top


def read_boundary_indeces_triang(dir: str | Path, Nx: int) -> Tuple[np.ndarray, np.ndarray]:
    """
    Return boundary indices for triangular lattices.

    For triangular lattices, boundary nodes are assumed to be the first 2*Nx
    nodes flagged as boundary.
    """
    nodes_path = Path(dir) / "nodes.inp"
    with nodes_path.open() as f:
        raw = f.readlines()[1:]

    boundary_flag = np.array([int(line.strip().split(" ")[2]) for line in raw])
    boundary_inds = np.where(boundary_flag == 1)[0][: 2 * Nx]

    half = boundary_inds.shape[0] // 2
    boundary_inds_bot = boundary_inds[:half]
    boundary_inds_top = boundary_inds[half:]

    return boundary_inds_bot, boundary_inds_top